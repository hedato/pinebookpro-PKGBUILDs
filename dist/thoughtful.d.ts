// Generated by dts-bundle v0.7.2

export class Matrix {
    data: number[][];
    constructor(data: number[][]);
    constructor(rows: number, columns: number);
    static rowVector(...components: number[]): Matrix;
    static columnVector(...components: number[]): Matrix;
    static rand(rows: number, columns: number): Matrix;
    static ones(rows: number, columns: number): Matrix;
    static eye(size: number): Matrix;
    apply(func: (number) => number): void;
    static join(m1: Matrix, m2: Matrix, pos?: 'top' | 'bottom' | 'left' | 'right'): Matrix;
    size(): number[];
    getNumberOfRows(): number;
    getNumberOfColumns(): number;
    getDimensions(): number[];
    set(row: number, column: number, val: number): void;
    get(row: number, column: number): number;
    getRowAsRowVector(row: number): Matrix;
    getColumnAsRowVector(column: number): Matrix;
    getAsScalar(): number;
    getArray(): number[][];
    copy(): Matrix;
    slice(startRow: number, endRow: number, startColumn: number, endColumn: number): Matrix;
    map(func: (val: number, row?: number, column?: number) => number): this;
    forEach(func: (val: number, row?: number, column?: number) => void): this;
    fill(newVal: number): this;
    scale(scl: number): this;
    add(tensor: Matrix): this;
    subtract(tensor: Matrix | Vector): this;
    multiply(tensor: Matrix | Vector): this;
    divide(tensor: Matrix | Vector): this;
    dot(tensor: Matrix | Vector): this;
    getVector(): void;
    transpose(): this;
    min(): Matrix;
    max(): Matrix;
    show(): this;
    getAsString(markup?: boolean, joinChar?: string, lineSpaceChar?: string, end?: string, fixed?: number): string;
}

export interface NumericDistanceFunction {
    (a: number[], b: number[]): number;
}
export class Distances {
    static EUCLIDEAN: NumericDistanceFunction;
    static TAXI: NumericDistanceFunction;
    static LEVENSHTEIN: (a: string, b: string) => any;
}

export namespace Normalization {
    class MinMaxNormalizer {
        constructor(data: number[][]);
        normalizeExampleData(): number[][];
        normalizeNewDataRow(row: number[]): number[];
        denormalize(row: number[]): number[];
    }
}

export namespace Maths {
    type Tensor = number[][];
    type Vector = number[][];
    type Matrix = number[][];
    function randomInt(min: number, max: number): number;
    function random(min: number, max: number): number;
    function argmax(args: number[]): number;
    function randomBool(): boolean;
    function round(value: number, decimals?: number): number;
    function sum(c: number[]): number;
    namespace Tensor2D {
        function getAsString(t: Tensor, markup?: boolean, joinChar?: string, lineSpaceChar?: string, end?: string, fixed?: number): string;
        namespace ElementWise {
            function add(...tensors: Tensor[]): number[][];
            function subtract(...tensors: Tensor[]): number[][];
            function multiply(...tensors: Tensor[]): number[][];
            function divide(...tensors: Tensor[]): number[][];
            function scale(t: Tensor, scl: number): number[][];
        }
        function dot(t1: Tensor, t2: Tensor): any[];
        function transpose(t: Tensor): number[][];
        function sameSize(...tensors: Tensor[]): boolean;
        /**
          *
          * @param size - Size of the 2D Tensor as an array with [#rows, #columns]
          * @param fill
          */
        function generate(size: number[], fillValue?: ((row?: number, column?: number) => number) | number): number[][];
        function fill(tensor: Tensor, fillValue: ((row?: number, column?: number) => number) | number): number[][];
        function getSize(t: Tensor): number[];
        function isValid(t: Tensor): boolean;
        function apply(t: Tensor, func: (value?: number, row?: number, col?: number) => number): number[][];
    }
}

export class Vector {
    constructor(components: number[]);
    static rand(size: number): Vector;
    copy(): Vector;
    getArray(): number[];
    append(vec: Vector): this;
    prepend(vec: Vector): this;
    readonly size: number;
    readonly magnitude: number;
    get(component: number): number;
    set(component: number, value: number): this;
    add(vec: Vector): this;
    subtract(vec: Vector): this;
    multiply(vec: Vector): this;
    divide(vec: Vector): this;
    pow(exponent: number): this;
    sum(): number;
    scale(scl: number): this;
    /**
      * this vector will be a row vector
      * @param vec column vector
      */
    dot(vec: Vector): number;
    apply(func: (number) => number): this;
}

export interface ANNOptions {
        learningRate: number;
        layers: number[];
        activationFunction: ActivationFunction;
        errorFunction: ErrorFunction;
        momentum: number;
}
export class FeedForwardNeuralNetwork {
        constructor(options: ANNOptions);
        /**
            * Creates new network with specified weights
            * @param weightData previously saved weights (using Network.exportWeights)
            * @param options network options
            */
        static restore(weightData: number[][][], options: ANNOptions): FeedForwardNeuralNetwork;
        /**
            * Fits given inputs to given target values by training the network
            * @param inputs inputs to the network
            * @param targetValues expected outputs for given input
            */
        fit(inputs: number[], targetValues: number[]): this;
        /**
            * Predict output values for given inputs
            * @param inputs input values
            */
        predict(inputs: number[]): number[];
        /**
            * Calculate the error for current outputs (not forward pass)
            * @param targetValues target values
            */
        getCurrentError(targetValues: number[]): number;
        /**
            * Calculates the error for given inputs
            * @param inputs inputs to network
            * @param targetValues expected output for given inputs
            */
        error(inputs: number[], targetValues: number[]): number;
        /**
            * Export the current weights of the network
            */
        exportWeights(): number[][][];
}

export interface ActivationFunction {
    output: (input: number) => number;
    der: (input: number) => number;
}
export class Activations {
    static TANH: ActivationFunction;
    static SIGMOID: ActivationFunction;
    static RELU: ActivationFunction;
    static LINEAR: ActivationFunction;
}

export interface ErrorFunction {
    error: (output: number, target: number) => number;
    der: (output: number, target: number) => number;
}
export class Errors {
    static SQUARE: ErrorFunction;
    static CROSS_ENTROPY: ErrorFunction;
}

export class ANN {
    constructor(options: {
        size: number[];
        activation: ActivationFunction;
        error: ErrorFunction;
        learningRate: number;
        momentum?: number;
    });
    cost(output: Maths.Vector, target: Maths.Vector): number;
    backward(target: Maths.Vector): number[][][];
    calculateGradients(deltas?: Maths.Vector[]): number[][][];
    updateWeightsAndBiases(gradients?: Maths.Vector[], deltas?: Maths.Vector[]): void;
    forward(input: Maths.Vector): number[][];
}

export namespace Utilities {
    function repeat(func: (iterations?: number) => any, iterations: number): void;
    function csvStringToJSON(csv: string, tryObjectParseIfPossible?: boolean, columnSeparator?: string, rowSeparator?: string): {}[] | (string | number)[][];
    function pickRandomFromArray(array: any[]): any;
    function tokenize(str: string, exp?: RegExp): string[];
}

export class LabelToValue {
    toValue(label: string): number;
    toLabel(value: number): string;
}

export namespace Generators {
    function clouds(clouds: number, dataPointsForCloud?: number, dimensions?: number, min?: number, max?: number, spread?: number): {
        center: number[];
        points: number[][];
    }[];
}

export class KNNClassifier {
    constructor(k?: number, distanceFunction?: NumericDistanceFunction);
    addData(classes: number[], data: number[][]): this;
    predict(input: number[], l2v?: LabelToValue): string | number;
}

export class KMeans {
    constructor(data: number[][], numberOfClusters: any);
    fitClusters(distanceFunction?: NumericDistanceFunction): number[][];
}

export class NaiveBayesClassifier {
    /**
      * words = {
      *  "word1": {
      *     "label1": count
      *     "label2": count
      *  }
      *  "word2": {
      *     "label1": count
      *     "label2": count
      *  }
      * }
      */
    words: {};
    docs: {};
    labels: string[];
    constructor(tokenizeMethod?: (string) => string[]);
    add(text: string, _label: number | string): void;
    classify(text: string): string;
}

